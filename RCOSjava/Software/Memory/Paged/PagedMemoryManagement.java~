// *************************************************************************/
// FILE     : PagedMemoryManagement.java
// PURPOSE  : Provides basic Memory/Page allocation.
//            It is very inefficent at the moment.
//            Probably should have two lists which
//            contains used and free memory blocks.
//            Combining and splitting memory blocks means it is
//            very slow and unrealistic.
// AUTHOR   : Bruce Jamieson
// MODIFIED : Andrew Newman
// HISTORY  : 27/03/96   Last Modified.
//            02/12/97   Fixed bug with deallocating memory.
//
// *************************************************************************/

package Software.Memory.Paged;

import java.lang.Integer;
import Hardware.Memory.MainMemory;
import Hardware.Memory.Memory;
import Software.Memory.MemoryReturn;
import Software.Memory.MemoryManagement;
import Software.Util.FIFOQueue;

public class PagedMemoryManagement implements MemoryManagement
{
  // Base page handler for the MMU
  private MainMemory myMainMemory;
  private FIFOQueue thePageTable;

  public PagedMemoryManagement(int MaxPages)
  {
    thePageTable = new FIFOQueue(10,1);
    myMainMemory = new MainMemory(MaxPages);
  }

  //Goes through the entire section of memory allocating
  //a specific set of memory with the same PID and
  //Type.  Size, in this case is the number of pages.
  public MemoryReturn open(int PID, int Type, int iSize)
  {
    System.out.println("/-----Open-----");
    // Allocate pages
    int count, noPages;
    short[] pages = new short[iSize];
    noPages = 0;
    for (count = 0; count < iSize; count++)
    {
      if (myMainMemory.getFreePages() != 0)
      {
        int freePageIndex = myMainMemory.findFirstFree();
        System.out.println("First free page: " + freePageIndex);
        if (freePageIndex >= 0)
        {
          myMainMemory.allocateMemory(freePageIndex);
          pages[noPages] = (short) freePageIndex;
          noPages++;
        }
      }
    }
    //Write allocation information to page table.
    System.out.println("PID:" + PID);
    System.out.println("Type:" + Type);
    System.out.println("Pages:" + pages);
    System.out.println("First Page:" + pages[0]);
    System.out.println("No Pages:" + noPages);
    PageTableEntry newPageTableEntry = new PageTableEntry((byte) PID,
      (byte) Type, pages,(short) noPages);
    thePageTable.insert(newPageTableEntry);
    System.out.println("Add page table entry of type: " + newPageTableEntry.getType());
    System.out.println("-----Open-----/");
    /*PageTableEntry tmpPageTable;
    thePageTable.goToHead();
    while(!thePageTable.atTail())
    {
      tmpPageTable = (PageTableEntry) thePageTable.peek();
      thePageTable.goToNext();
    }*/
    return (new MemoryReturn(PID, (byte) Type, noPages, pages));
  }

  // Deallocate based on Process ID.
  public MemoryReturn close(int PID)
  {
    PageTableEntry tmpPage;

    thePageTable.goToHead();
    int totalPages=0;
    short[] indexTotalPages = new short[20];

    while (!thePageTable.atTail())
    {
      tmpPage = (PageTableEntry) thePageTable.peek();
      if (tmpPage.getPID() == ((byte) PID))
      {
        tmpPage = (PageTableEntry) thePageTable.retrieveCurrent();
        for(int count = 0; count < tmpPage.getTotalNumberOfPages(); count++)
        {
          myMainMemory.freeMemory(tmpPage.getPages()[count]);
          for (int count2 = 1; count2 < Memory.DEFAULT_SEGMENT-1; count2++)
            myMainMemory.allocateMemory(tmpPage.getPages()[count]);
          indexTotalPages[totalPages] = tmpPage.getPages()[count];
          totalPages++;
        }
      }
      else
      {
        thePageTable.goToNext();
      }
    }
    return (new MemoryReturn(PID, (byte) 0, totalPages, indexTotalPages));
  }

  // Get all memory from numerous pages belonging to PID of type Type.
  public Memory getAllMemory(int PID, int Type, int Size)
  {
    PageTableEntry tmpPageTable;
    int count;
    thePageTable.goToHead();
    Memory tmpMemory = new Memory(Size);
    while (!thePageTable.atTail())
    {
      tmpPageTable = (PageTableEntry) thePageTable.peek();
      System.out.println("Page table entry: ");
      System.out.println("PID: " + tmpPageTable.getPID() +
        "Type: " + tmpPageTable.getType() +
        "First Page: " + tmpPageTable.getPages()[0]);
      thePageTable.goToNext();
    }
    thePageTable.goToHead();
    tmpMemory = new Memory(Size);
    while (!thePageTable.atTail())
    {
      tmpPageTable = (PageTableEntry) thePageTable.peek();
      if ((tmpPageTable.getPID() == ((byte) PID)) &&
          (tmpPageTable.getType() == ((byte) Type)))
      {
        System.out.println("/-----Get All Memory-----");
        System.out.println("Looking for type: " + Type);
        System.out.println("Got page table type: " + tmpPageTable.getType());
        tmpMemory = myMainMemory.getMemory(tmpPageTable.getPages()[0]);
        System.out.println("Memory is before: " + tmpMemory);
        for(count = 1; count < tmpPageTable.getTotalNumberOfPages(); count++)
        {
          tmpMemory = Memory.combineMemory(tmpMemory,
                      myMainMemory.getMemory(tmpPageTable.getPages()[count]));
        }
        System.out.println("Memory is after: " + tmpMemory);
        System.out.println("-----Get All Memory-----/");
        return (tmpMemory);
      }
      thePageTable.goToNext();
    }
    return null;
  }

  // Read page number Offset belonging to PID of type Type.
  public Memory readPage(int PID, int Type, int Offset)
  {
    return (readBytes(PID, Type, Memory.DEFAULT_SEGMENT, Offset*Memory.DEFAULT_SEGMENT));
  }

  //Read a number of bytes with given PID, Type, Size and Offset.
  public Memory readBytes(int PID, int Type, int Size, int Offset)
  {
    Memory tmpMemory = getAllMemory(PID, Type, Size);
    System.out.println("**Reading PID: " + PID + " Type: " + Type + " Read: " + tmpMemory.toString());
    if (tmpMemory != null)
    {
      return (tmpMemory.read(Offset, Size));
    }
    return null;
  }

  // Write page number Offset belonging to PID of type Type with Memory.
  public void writePage(int PID, int Type, int Offset, Memory myMemory)
  {
    writeBytes(PID, Type, Memory.DEFAULT_SEGMENT, Offset*Memory.DEFAULT_SEGMENT,
      myMemory);
  }

  // Write bytes given PID, Type, Size, Offset with Memory.
  public void writeBytes(int PID, int Type, int Size, int Offset, Memory Mem)
  {
    // Get all Memory from segments
    Memory tmpMemory = getAllMemory(PID, Type, Size);
    if (tmpMemory != null)
    {
      // Write new values to one large block of memory
      tmpMemory.write(Offset, Mem);
      // Write memory into segments
      PageTableEntry tmpPageTable;
      thePageTable.goToHead();
      while (!thePageTable.atTail())
      {
        tmpPageTable = (PageTableEntry) thePageTable.peek();
        if ((tmpPageTable.getPID() == ((byte) PID)) &&
            (tmpPageTable.getType() == ((byte) Type)))
        {
          int count;
          for (count = 0; count < tmpPageTable.getTotalNumberOfPages(); count++)
          {
            myMainMemory.setMemory(tmpPageTable.getPages()[count],
              tmpMemory.segmentMemory(count*myMainMemory.getMemory(tmpPageTable.getPages()[count]).getSegmentSize(),
                myMainMemory.getMemory(tmpPageTable.getPages()[count]).getSegmentSize(),
                tmpMemory.isAllocated()));
          }
        }
        thePageTable.goToNext();
      }
      thePageTable.goToHead();
      while(!thePageTable.atTail())
      {
        tmpPageTable = (PageTableEntry) thePageTable.peek();
        thePageTable.goToNext();
      }
    }
  }
}
